---
title: "How large can we go"
author: "Jan Salecker"
date: "8/31/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## How large can we go

This analysis is intended to assess the maximum landscape size we are comfortable with.
We will vary the landscape size only and see how the energy develops.
We start with the easiest case: strong correlation between species and low gamma.

## Test 01

```{r packages, echo=FALSE, message=FALSE, results='hide'}
library(spectre)
library(tidyverse)
library(future)
library(virtualspecies)
library(furrr)
library(clustermq)
library(landscapetools)

## Source spectre analysis functions (R folder)
sapply(list.files("../R", full.names = TRUE), source)
set.seed(3562347)
exec <- "HPC" # "HPC"
dir.hpc <- file.path("/home/uni08/jsaleck/spectre")
dir.cloud <- file.path("/home/jan/netlogo_jan/spectre_usecase")
```
```{r parameters}
## Constant parameters:
replicates <- 1
max_runs <- 50000
energy_threshold <- 0
beta <- 0.75

## Variable parameters:
landscape_size <- c(10,25,50,75,100)
corr_within <- 0.5
corr_among <- 0.1
gamma <- c(100,200,300,400)
random_seeds <- round(runif(replicates) * 100000)
```
```{r exec, echo=FALSE, eval=FALSE}
## Generate parameter matrix:
parameters <- expand.grid(landscape_size = landscape_size, 
                          corr_within = corr_within,
                          gamma = gamma, 
                          beta = beta,
                          corr_among = corr_among,
                          random_seeds = random_seeds)

if (exec == "local") {
  plan(multisession)
  results <- furrr::future_map_dfr(seq(nrow(parameters)), function(x) {
    virtualspecies_simfun(siminputrow = x, 
                          parameters = parameters,
                          max_runs = max_runs,
                          energy_threshold = energy_threshold,
                          writeRDS = FALSE,
                          outdir = dir.cloud)
  })
}
if (exec == "HPC") {
  
  maxjobs.hpc <- 2000
  njobs <- min(nrow(parameters), maxjobs.hpc)
  jobIDs <- seq(nrow(parameters))
  
  results <- clustermq::Q(fun = virtualspecies_simfun, 
                          siminputrow = jobIDs,
                          const = list(parameters = parameters,
                                       max_runs = max_runs,
                                       energy_threshold = energy_threshold,
                                       writeRDS = TRUE,
                                       outdir = dir.hpc),
                          export = list(), 
                          seed = 42, 
                          n_jobs = njobs, 
                          template = list(job_name = "spectre", # define jobname
                                          log_file = "spectre.log", # define logfile name
                                          queue = "medium",  # define HPC queue
                                          service = "normal", # define HPC service
                                          walltime = "48:00:00", # define walltime
                                          mem_cpu = "4000")) # define memory per cpu   
  results <- dplyr::bind_rows(results)
}

#### Restore results from rds files if neccessary:
#results <- purrr::map_dfr(list.files(dir.cloud, pattern = "rds", full.names = TRUE), function(x) {
#  res.x <- readRDS(x)
#  return(res.x)
#})

#### STORE RESULTS:
saveRDS(results, file=file.path(dir.cloud, "data", "virtualspecies_04_howlargecanwego_data.rds"))

```

## Analysis


#### Energy over time

```{r plot1}
library(tidyverse)
results <- readRDS("../data/virtualspecies_04_howlarge_temp.rds")

energy <- purrr::map_dfr(1:nrow(results), function(x) {
  energy <- results$spp.spectre[[x]]$energy %>% 
    dplyr::mutate(landscape_size = results$landscape_size[x]) %>% 
    dplyr::mutate(corr_within = results$corr_within[x]) %>% 
    dplyr::mutate(corr_among = results$corr_among[x]) %>%
    dplyr::mutate(gamma = results$gamma[x]) %>% 
    dplyr::mutate(beta = results$beta[x]) %>% 
    dplyr::mutate(random_seeds = results$random_seeds[x])
})

## PLOT 1: Minimum energy
energy_min <- energy %>% 
  dplyr::group_by(random_seeds,landscape_size, gamma, corr_within, corr_among) %>% 
  dplyr::summarise(energy = min(energy)) %>% 
  dplyr::group_by(landscape_size, gamma, corr_within, corr_among) %>% 
  dplyr::mutate(min_energy_mu = mean(energy),
                min_energy_sd = sd(energy))
  

ggplot(energy_min, aes(x=gamma, y=min_energy_mu, color=factor(landscape_size), group=landscape_size)) +
  geom_pointrange(aes(ymin=min_energy_mu - min_energy_sd, ymax=min_energy_mu + min_energy_sd)) +
  geom_line() +
  xlab("Gamma") +
  ylab("Minimum energy") +
  guides(color=guide_legend(title="Landscape size")) +
  ggsci::scale_color_jco() +
  ggthemes::theme_tufte(base_size = 12)

ggsave("../figures/virtualspecies_04_bench_min_energy.png", width=6, height=6, dpi=300)


## PLOT 2: Relative error in commonness
results_rec <- purrr::map_dfr(1:nrow(results), function(x) {
  out.tib <- results[x,]
  spp <- results$spp.virtual[[x]]
  solution <- spectre::generate_data_virtualspecies_to_solution(spp)
  target <- spectre:::calculate_solution_commonness_rcpp(solution)
  optimized_grid <- results$spp.spectre[[x]]$optimized_grid
  out.tib$rec <- calculate_rec(target, optimized_grid)
  return(out.tib)
})

results_rec <- results_rec %>% 
  dplyr::group_by(landscape_size, gamma, corr_within, corr_among) %>% 
  dplyr::summarise(rec_mu = mean(rec),
                   rec_sd = sd(rec))


ggplot(results_rec, aes(x=gamma, y=rec_mu, color=factor(landscape_size), group=landscape_size)) +
  geom_pointrange(aes(ymin=rec_mu - rec_sd, ymax=rec_mu + rec_sd)) +
  geom_line() +
  xlab("Gamma") +
  ylab("Relative error in commonness") +
  guides(color=guide_legend(title="Landscape size")) +
  ggsci::scale_color_jco() +
  ggthemes::theme_tufte(base_size = 12)

ggsave("../figures/virtualspecies_04_bench_rec.png", width=6, height=6, dpi=300)

```

#### Minimum energy

standardized regression coefficient:
summary(lm(scale(energy) ~ scale(landscape_size) * scale(gamma) * scale(corr_within) * scale(corr_among), data=energy_min))

#### Realtive commonness error



