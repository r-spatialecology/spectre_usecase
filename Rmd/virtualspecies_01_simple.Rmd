---
title: "Generate virtual communities for spectre analyses"
author: "Jan Salecker"
date: "8/27/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Generate virtual communities for spectre analyses

This vignette demonstrates how the NLMR-virtualspecies approach can be used to generate data that can be run through the spectre algorithm. This approach allows to generate a complete community dataset (explicit presence absence of species). From this dataset we can derive species richness for each site and dissimilarity between site pairs. This information is fed into spectre and a new community matrix will be build by spectre. Afterwards we can compare the original community with the optimized community and assess how spectre performed.

To allow for a variety of scenarios, the NLMR-virtualspecies workflow allows to set some crucial parameters:

* landscape_size -> cols/rows of the simulated landscape
* gamma -> maximum number of species on the landscape
* corr_within -> spatial autocorrelation within species
* corr_among -> spatial autocorrelation among species
* beta -> width of species distributions

The workflow uses three new functions:

* generate_data_virtualspecies.R -> main function for generating virtual communities
* generate_data_virtualspecies_to_solution.R -> convert a virtual community to a solution matrix
* plot_virtualspecies.R -> generate plots for virtual species communities

The community generation builds upon two R packages: NLMR and virtualspecies.
The virtualspecies package uses habitat suitability maps and generates presence/absence maps from these suitability maps.
We simply generate these suitability maps beforehand with NLMR, which allows us to control spatial autocorrelation in these maps.
However, instead of using the same suitability map for all species, we generate a bunch of suitability maps. These may represent different niches or species groups.

Here is a more technical description of what happens within the function `generate_data_virtualspecies()`:

* First, the number of species communities (or groups) is estimated. 
    * We calculate the number of groups as `communities= gamma / (gamma * corr_among)`. For example, if `gamma = 100` and `corr_among = 1`, there is only one community and all species will use the same habitat suitability map. 
    * If `gamma = 100` and `corr_among = 0.1`, there are 10 communities with ~10 species each. Thus, we will generate 10 different suitability maps. As a result, there is less autocorrelation among species.
* Second, the suitability maps are created with `nlm_gaussianfield()`. 
    * The gaussianfield approach allows us to define spatial autocorrelation within each suitability map. 
    * Thus, when `corr_within = 1` habitat suitability is highly clustered. If `corr_within = 0` there is no clustering of habitat suitability.
* Third, virtualspecies distributions are created with `virtualspecies::convertToPA()`.
    * We loop through all species (gamma)
    * For each species we randomly select one of the generated suitability maps
    * The species distribution is then generated with `virtualspecies::convertToPA()`
    * Results are reported as raster stack with presence/absence maps


## Example of the NLMR-virtualspecies approach

#### Initialization

We start with loading some packages.
We define the parameters listed above and use the `generate_data_virtualspecies()` function to generate our virtual community.
Afterwards we can use the `plot_virtualspecies()` function to investigate our virtual community.

```{r init}
library(spectre)
library(raster)
## Source spectre analysis functions (R folder)
sapply(list.files("../R", full.names = TRUE), source)
set.seed(56737)

## Step 1: Generate virtualspecies community
ncol <- 5
nrow <- 5
gamma <- 100
corr_within <- 1 # strength of spatial autocorrelation within species
corr_among <- 1 # strength of spatial correlation among species (% of gamma)
beta <- 0.5  # lower beta = wider species distributions

# Generate species and create list of alpha diversity:
spp <- generate_data_virtualspecies(ncol=ncol, nrow=nrow, corr_within = corr_within, corr_among = corr_among, gamma = gamma, beta = beta)

# plot species distributions:
virtualspecies_plot(spp, type="incidence")
virtualspecies_plot(spp, type="richness")
```

#### Preparation of solution

Now we have our community, but for evaluating the data through spectre, we need a list of alpha diversity (species richness) in each site and a solution matrix (site by site commonness).

We can extract the alpha by calculating the sum of our virtual community raster stack. For the commonness, we first calculate a solution matrix with the function `generate_data_virtualspecies_to_solution()` and use the spectre function `calculate_solution_commonness_rcpp()` to convert that to a commonness matrix.

```{r prepare}
## Prepare data for spectre algorithm
alpha <- getValues(sum(spp))
solution <- generate_data_virtualspecies_to_solution(spp)
target <- spectre:::calculate_solution_commonness_rcpp(solution)
```

#### Run optimization

Now we have everything we need to run spectre:

```{r optimize}
#### Step 3: Execute optimization
max_runs <- 200
res_min_conf <- spectre::run_optimization_min_conf_0(alpha_list=alpha, 
                                                     total_gamma=gamma, 
                                                     target=target, 
                                                     max_iterations=max_runs,
                                                     energy_threshold = 0.0)
spectre::plot_energy(res_min_conf)
```

#### Post-processing

If the optimization was successful, we might want to look at our resulting community.
Here, we first convert the optimized grid of the spectre algorithm to a raster stack to allow for comparison with the initial virtual community. Afterwards, we can use the `plot_virtualspecies()` function to look at the richness grid and the incidence grid.
We can also plot a side by side comparison of both richness grids. Here, in this small toy example, both species richness grids are completely equal, so alpha diversity was matched very accurately.

```{r plot}
## Calculate relative error in commonness:
calculate_rce(target, res_min_conf$optimized_grid)

## Convert to raster stack:
spp.spectre <- stack(purrr::map(seq(nrow(res_min_conf$optimized_grid)), function(x) {
  r <- raster(matrix(res_min_conf$optimized_grid[x,], nrow=nrow, ncol=ncol, byrow = TRUE))
  extent(r) <- extent(spp)
  return(r)
}))

## Plot:
virtualspecies_plot(spp.spectre, type="incidence")
virtualspecies_plot(spp.spectre, type="richness")

## Side by side comparison:
virtualspecies_plot(species.stack=list("original" = spp, "spectre" = spp.spectre), type="richness")


```






